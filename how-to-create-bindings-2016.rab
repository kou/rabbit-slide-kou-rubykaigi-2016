= Ruby bindings 2016

: subtitle
   How to create bindings 2016

: author
   Kouhei Sutou
: institution
   ClearCode Inc.
: content-source
   RubyKaigi 2016
: date
   2016-09-08
: allotted-time
   35m
: theme
   .

= Silver sponsor

  # img
  # src = images/clear-code-silver-sponsor.png
  # relative_height = 100

# == Slide properties

# : enable-title-on-image
#    false

= Goal\n(('note:ç›®æ¨™'))

(('tag:center'))
(('tag:large'))
You know about\n
how to create bindings

(('tag:center'))
(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®ä½œã‚Šæ–¹ã‚’çŸ¥ã‚‹ã“ã¨'))

= Bindings?\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¨ã¯'))

  * Glue of (('note:(mainly)')) C and Ruby\n
    (('note:ä¸»ã«Cã¨Rubyã‚’ã¤ãªãã‚‚ã®'))

    * (('wait'))You can use features implemented in C from Ruby\n
      (('note:Cã§å®Ÿè£…ã•ã‚ŒãŸæ©Ÿèƒ½ã‚’Rubyã‹ã‚‰ä½¿ãˆã‚‹'))

    * (('wait'))e.g.: Socket, OpenSSL, YAML, ...\n
      (('note:ä¾‹ï¼šã‚½ã‚±ãƒƒãƒˆã€OpenSSLã€YAMLâ€¦'))

= Bindings\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))

  # image
  # src = images/bindings.svg
  # relative_height = 100

== slide properties

: enable-title-on-image
   false

= But why do I know?\n(('note:ã§ã‚‚ã€ã©ã†ã—ã¦çŸ¥ã‚‹ã¨ã„ã„ã®ï¼Ÿ'))

  * (('wait'))To use Ruby in more cases\n
    (('note:Rubyã‚’ã‚‚ã£ã¨ã„ã‚ã‚“ãªå ´é¢ã§ä½¿ã†ãŸã‚'))
    * e.g.: (('tag:x-small:Machine leaning, multimedia, full text search, cipher and so on'))\n
      (('note:ä¾‹ï¼šæ©Ÿæ¢°å­¦ç¿’ã€ç”»åƒãƒ»å‹•ç”»ãƒ»éŸ³å£°å‡¦ç†ã€å…¨æ–‡æ¤œç´¢ãƒ»æš—å·'))
  * (('wait'))We can use existing good features in Ruby by bindings\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒã‚ã‚‹ã¨æ—¢å­˜ã®ã„ã„æ©Ÿèƒ½ã‚’Rubyã§ä½¿ãˆã‚‹'))

= Incr. bindings developer\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°é–‹ç™ºè€…ãŒå¢—ãˆã‚‹ã¨ã„ã„ãª'))

  * How about becoming a bindings developer?\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°é–‹ç™ºè€…ã«ãªã‚Šã¾ã›ã‚“ã‹ï¼Ÿ'))
    * (('wait'))To expand Ruby use cases!\n
      (('note:Rubyã®é©ç”¨å¯èƒ½é ˜åŸŸã‚’å¢—ã‚„ã™ãŸã‚ã«ï¼'))
    * (('wait'))Not just an user for\n
      provided features\n
      (('note:æä¾›ã•ã‚ŒãŸæ©Ÿèƒ½ã‚’ä½¿ã†1ãƒ¦ãƒ¼ã‚¶ãƒ¼ã§ã¯ãªã'))

= Summary\n(('note:æ¦‚è¦'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, Ext, Ext, lib\nffi, lib\nffi
  Impl.\nby, Hand, Gene-rate, Hand, Gene-rate

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= Demo\n(('note:ãƒ‡ãƒ¢'))

How powerful auto generated bindings\n
(('note:è‡ªå‹•ç”Ÿæˆã•ã‚ŒãŸãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãŒã„ã‹ã«å¼·åŠ›ã‹'))

= What is ext?\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã£ã¦ãªã«ï¼Ÿ'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, ((*Ext*)), ((*Ext*)), lib\nffi, lib\nffi
  Impl.\nby, Hand, Gene-rate, Hand, Gene-rate

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= Extension library\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã¨ã¯'))

  * Ruby library written in ((*C*))\n
    (('note:Cã§æ›¸ã‹ã‚ŒãŸRubyç”¨ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))
  * (('wait'))Most bindings are ext lib\n
    (('note:å¤šãã®ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¯æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã¨ã—ã¦å®Ÿè£…'))
    * (({openssl})) is ext lib and bindings\n
      (('note:(({oepnssl}))ã¯æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã§ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))
    * Exc.: (({stringio})) is ext lib but...\n
      (('note:ä¾‹å¤–ï¼š(({stringio}))ã¯æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã ãŒâ€¦'))

= Ext lib and bindings\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã¨ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))

  # image
  # src = images/extension-library-and-bindings.svg
  # relative_height = 100

== slide properties

: enable-title-on-image
   false

= What is libffi?\n(('note:libffiã£ã¦ãªã«ï¼Ÿ'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, Ext, Ext, ((*lib\nffi*)), ((*lib\nffi*))
  Impl.\nby, Hand, Gene-rate, Hand, Gene-rate

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= libffi and FFI: 1\n(('note:libffiã¨FFIã¨ã¯ï¼š1'))

  * libffi: Library to impl. FFI
  * (('wait'))((*F*))oreign ((*F*))unction ((*I*))nterface
    * Generally:\n
      All APIs to impl. bindings\n
      (('note:ä¸€èˆ¬çš„ã«ã¯ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®ã™ã¹ã¦ã®API'))
    * Ruby doesn't use "FFI" term\n
      (('note:Rubyã§ã¯ã€ŒFFIã€ã¨ã„ã†å˜èªã‚’ä½¿ã‚ãªã„'))

= libffi and FFI: 2\n(('note:libffiã¨FFIã¨ã¯ï¼š2'))

  * Ruby FFI
    * (('wait'))Library based on libffi\n
      (('note:libffiã‚’ä½¿ã£ãŸãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))
    * (('wait'))Provides ((*Ruby*)) API\n
      to implement bindings\n
      (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’å®Ÿè£…ã™ã‚‹ãŸã‚ã®Rubyãƒ¬ãƒ™ãƒ«ã®APIã‚’æä¾›'))

= libffi and bindings\n(('note:libffiã¨ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))

  # image
  # src = images/libffi-and-bindings.svg
  # relative_height = 100

== slide properties

: enable-title-on-image
   false

= Impl. language\n(('note:å®Ÿè£…è¨€èª'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, Ext, Ext, lib\nffi, lib\nffi
  Impl.\nlang, C, C+Î±, Ruby, Ruby

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= Ext impl. by\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®å®Ÿè£…æ–¹æ³•'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, Ext, Ext, lib\nffi, lib\nffi
  Impl.\nby, ((*Hand*)), ((*Generate*)), Hand, Gene-rate

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= Ext impl. by: Target\n(('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®å®Ÿè£…æ–¹æ³•ï¼šå¯¾è±¡'))

  # coderay c
  /* hello.h */
  #pragma once
  typedef struct hello_t Hello;
  Hello      *hello_new    (void);
  void        hello_free   (Hello *hello);
  const char *hello_message(Hello *hello);

= Ext impl. by hand\n(('note:æ‰‹å‹•ã§ã®æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®å®Ÿè£…'))

(('note:https://github.com/kou/rabbit-slide-kou-rubykaigi-2016/blob/master/c-api/bindings/hello.c'))

  # coderay c
  #include <ruby.h>

  #include <hello.h>

  static void
  rb_hello_free(void *data)
  {
    Hello *hello = data;
    hello_free(hello);
  }

  static const rb_data_type_t rb_hello_type = {
    "Hello",
    {
      NULL,
      rb_hello_free,
      NULL,
    },
    NULL,
    NULL,
    RUBY_TYPED_FREE_IMMEDIATELY,
  };

  static VALUE
  rb_hello_alloc(VALUE klass)
  {
    return TypedData_Wrap_Struct(klass, &rb_hello_type, NULL);
  }

  static VALUE
  rb_hello_initialize(VALUE self)
  {
    Hello *hello;
    hello = hello_new();
    DATA_PTR(self) = hello;
    return Qnil;
  }

  static VALUE
  rb_hello_message(VALUE self)
  {
    Hello *hello;
    const char *message;

    TypedData_Get_Struct(self, Hello, &rb_hello_type, hello);
    message = hello_message(hello);

    return rb_str_new_cstr(message);
  }

  void
  Init_hello(void)
  {
    VALUE hello;

    hello = rb_define_class("Hello", rb_cData);
    rb_define_alloc_func(hello, rb_hello_alloc);
    rb_define_method(hello, "initialize", rb_hello_initialize, 0);
    rb_define_method(hello, "message", rb_hello_message, 0);
  }

= Ext impl. by generation\n(('note:è‡ªå‹•ç”Ÿæˆã§ã®æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®å®Ÿè£…'))

  * (('wait'))SWIG can generate impl.\n
    (('note:Simplified Wrapper and Interface Generator'))\n
    (('note:SWIGã§å®Ÿè£…ã‚’ç”Ÿæˆã§ãã‚‹'))
  * (('wait'))An user
    * TensorFlow: A library for machine intelligence\n
      (('note:TensorFlowï¼šæ©Ÿæ¢°çŸ¥èƒ½ã®ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))\n
      Uses to generate Python bindings\n
      (('note:Pythonãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç”Ÿæˆã™ã‚‹ãŸã‚ã«ä½¿ç”¨'))

= Ext impl. by SWIG\n(('note:SWIGã§ã®æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®å®Ÿè£…'))

  # coderay c
  // swig -ruby hello.i -> hello_wrap.c
  %module hello
  %{
  #include <hello.h>
  %}
  %include <hello.h>

= Use ext by SWIG\n(('note:SWIGã§ä½œã£ãŸæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½¿ã†'))

  irb(main):001:0> require "hello"
  => true
  irb(main):002:0> hello = Hello.hello_new
  => #<SWIG::TYPE_p_hello_t:0x000...>
  irb(main):003:0> Hello.hello_message(hello)
  => "Hello"
  irb(main):004:0> Hello.hello_free(hello)
  => nil
  # Raw C API... :<

= By SWIG again\n(('note:SWIGã§ã‚‚ã†ä¸€åº¦'))

  # coderay c
  %module hello
  %{#include <hello.h>%}
  typedef struct hello_t {
    %extend {
      hello_t() {return hello_new();}
      ~hello_t() {hello_free($self);}
      const char *message() {return hello_message($self);}
    }
  } Hello;

= Use again\n(('note:ã‚‚ã†ä¸€åº¦ä½¿ã†'))

  irb(main):001:0> require "hello"
  => true
  irb(main):002:0> hello = Hello::Hello.new
  => #<Hello::Hello:0x000...>
  irb(main):003:0> hello.message
  => "Hello"
  # Object oriented API!

= Wrap up1: Ext\n(('note:ã¾ã¨ã‚1ï¼šæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))

  * (('wait'))By hand: Need many works\n
    (('note:æ‰‹å‹•ï¼šãŸãã•ã‚“æ›¸ã‹ãªã„ã¨ã„ã‘ãªã„'))
  * (('wait'))By generation: Less works\n
    (('note:ç”Ÿæˆï¼šæ›¸ãã“ã¨ãŒå°‘ãªã„'))
    * Need more works for easy to use\n
      (('note:ä½¿ã„ã‚„ã™ã„APIã«ã™ã‚‹ã«ã¯ãŸãã•ã‚“æ›¸ã‹ãªã„ã¨ã„ã‘ãªã„'))

= Wrap up2: Ext\n(('note:ã¾ã¨ã‚2ï¼šæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼'))

  * On maintenance\n
    e.g.: New functions\n
    (('note:ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹æ™‚ï¼šï¼ˆä¾‹ï¼šæ–°ã—ã„é–¢æ•°ãŒè¿½åŠ ã•ã‚ŒãŸï¼‰'))
    * (('wait'))By hand: Need more works\n
      (('note:æ‰‹å‹•ï¼šè¿½åŠ ä½œæ¥­ã‚ã‚Š'))
    * (('wait'))By generation: No more works\n
      (('note:ç”Ÿæˆï¼šè¿½åŠ ä½œæ¥­ãªã—'))\n
      This is a large benefit!\n
      (('note:ã“ã‚Œã¯å¤§ããªåˆ©ç‚¹ï¼'))

= libffi impl. by\n(('note:libffiãƒ™ãƒ¼ã‚¹ã§ã®å®Ÿè£…æ–¹æ³•'))

  # RT

  , Extâ˜…, SWIG, FFI, GIâ˜†

  Base\nTech, Ext, Ext, lib\nffi, lib\nffi
  Impl.\nby, Hand, Gene-rate, ((*Hand*)), ((*Generate*))

(('note:â˜… Extension libraryï¼ˆæ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ï¼‰'))\n
(('note:â˜† GObject Introspection: Recommendedï¼ˆã‚ªã‚¹ã‚¹ãƒ¡ï¼‰'))

= libffi impl. by hand\n(('note:æ‰‹å‹•ã§ã®libffiãƒ™ãƒ¼ã‚¹ã®å®Ÿè£…'))

TODO

= libffi impl. by generation\n(('note:è‡ªå‹•ç”Ÿæˆã§ã®libffiãƒ™ãƒ¼ã‚¹ã®å®Ÿè£…'))

TODO

= Appendix\n(('note:ä»˜éŒ²'))

  * Ext, SWIG, FFI, GI impl. details
  * How to create fat gem

= Method1: C API\n(('note:æ–¹æ³•1ï¼šC API'))

  * Use C API provided by Ruby\n
    (('note:RubyãŒæä¾›ã™ã‚‹C APIã‚’ä½¿ã†'))
    * (('wait'))It's for creating ext lib\n
      (('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½œã‚‹ãŸã‚ã®API'))

= C API: Define class\n(('note:C APIï¼šã‚¯ãƒ©ã‚¹å®šç¾©'))

  # coderay c
  #include <ruby.h>
  void
  Init_hello(void)
  {
    rb_define_class("Hello", rb_cObject);
    /* Ruby: class Hello; end */
  }

= C API: Initialize\n(('note:C APIï¼šåˆæœŸåŒ–'))

  # coderay c
  #include <ruby.h>
  void
  Init_#{module_name}(void)
  {
    /* require "#{module_name}"
       calls this function */
  }

= C API: Init example\n(('note:C APIï¼šåˆæœŸåŒ–ä¾‹'))

  # coderay c
  #include <ruby.h>
  void
  Init_hello(void)
  {
    /* require "hello"
       calls this function */
  }

= C API: Define method\n(('note:C APIï¼šãƒ¡ã‚½ãƒƒãƒ‰å®šç¾©'))

  # coderay c
  static VALUE hello_to_s(VALUE self) {
    return rb_str_new_cstr("Hello");
  }
  void Init_hello(void) {
    VALUE hello;
    hello = rb_define_class("Hello", rb_cObject);
    rb_define_method(hello, "to_s", hello_to_s, 0);
  }

= C API: Build1\n(('note:C APIï¼šãƒ“ãƒ«ãƒ‰1'))

  # coderay ruby
  # extconf.rb
  require "mkmf"
  # "hello" == "#{module_name}"
  create_makefile("hello")

= C API: Build2\n(('note:C APIï¼šãƒ“ãƒ«ãƒ‰2'))

  % ruby extconf.rb
  % make
  (hello.so is generated.)

= C API: Use\n(('note:C APIï¼šä½¿ã†'))

  % irb -I .
  irb(main):001:0> require "hello"
  => true
  irb(main):002:0> hello = Hello.new
  => #<Hello:0x00000001fd15a0>
  irb(main):003:0> hello.to_s
  => "Hello"

= C API: Create bindings\n(('note:C APIï¼šãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½œã‚‹'))

  * C API is for ext lib\n
    (('note:C APIã‚’ä½¿ã†ã¨æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚’ä½œã‚Œã‚‹'))
  * (('wait'))C API is also for bindings\n
    (('note:C APIã‚’ä½¿ã†ã¨ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚‚ä½œã‚Œã‚‹'))
  * (('wait'))Show it from now just FYI\n
    (('note:å‚è€ƒã¾ã§ã«ã“ã‚Œã‹ã‚‰ä½œã‚Šæ–¹ã‚’ç´¹ä»‹ã™ã‚‹'))

= C API: Again, FYI!\n(('note:C APIï¼šå‚è€ƒã®ãŸã‚ã§ã™ã‚ˆï¼'))

  * You don't need to understand about details now\n
    (('note:ã“ã®å ´ã§ã¯è©³ç´°ã‚’ã‚ã‹ã‚‰ãªãã¦ã‚‚æ§‹ã‚ãªã„'))\n
    * (('note:See also: Ruby:doc/extension.rdoc'))
    * (('note:See also: kou/rabbit-slide-kou-rubykaigi-2016'))
  * You just need to know how many steps exist\n
    (('note:ã©ã®ãã‚‰ã„ã‚¹ãƒ†ãƒƒãƒ—ãŒã‚ã‚‹ã‹ã‚ã‹ã‚Œã°ååˆ†'))

= Bindings target\n(('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°å¯¾è±¡'))

  # coderay c
  /* hello.h */
  #pragma once
  typedef struct hello_t Hello;
  Hello      *hello_new    (void);
  void        hello_free   (Hello *hello);
  const char *hello_message(Hello *hello);

= Define class\n(('note:ã‚¯ãƒ©ã‚¹å®šç¾©'))

  # coderay c
  void
  Init_hello(void)
  {
    VALUE hello;
    /* Ruby: class Hello < Data; end */
    hello = rb_define_class("Hello", rb_cData);
    rb_define_alloc_func(hello, rb_hello_alloc);
  }

= Wrap struct\n(('note:æ§‹é€ ä½“ã‚’ãƒ©ãƒƒãƒ—'))

  # coderay c
  static VALUE
  rb_hello_alloc(VALUE klass)
  {
    /* Allocate memory for wrapping
       target struct in C (= Hello struct). */
    return TypedData_Wrap_Struct(klass,
                                 &rb_hello_type,
    /* Target struct is NULL at this phase. */
                                 NULL);
  }

= Define type metadata\n(('note:å‹ç”¨ã®ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ã‚’å®šç¾©'))

  # coderay c
  static const rb_data_type_t rb_hello_type = {
    "Hello", /* Type name. */
    /* Mark, free, size functions. */
    {NULL, rb_hello_free, NULL,},
    NULL, /* Parent. It must be NULL. */
    NULL, /* Wrapped target struct. */
    RUBY_TYPED_FREE_IMMEDIATELY,
  };

= Free function\n(('note:ãƒ¡ãƒ¢ãƒªãƒ¼è§£æ”¾é–¢æ•°'))

  # coderay c
  static void
  rb_hello_free(void *data)
  {
    Hello *hello = data;
    /* Just call the free function. */
    hello_free(hello);
  }

= Register (({initialize}))\n(('note:(({initialize}))ç™»éŒ²'))

  # coderay c
  void Init_hello(void) {
    /* VALUE hello = Hello class */
    /* Ruby: def initialize; end */
    rb_define_method(hello,
          /* Name */ "initialize",
                     rb_hello_initialize,
    /* No argument */ 0);
  }

= Initialize\n(('note:åˆæœŸåŒ–'))

  # coderay c
  static VALUE
  rb_hello_initialize(VALUE self)
  {
    Hello *hello;
    hello = hello_new();    /* Create a target */
    DATA_PTR(self) = hello; /* Wrap the target */
    return Qnil;
  }

= Bind method\n(('note:ãƒ¡ã‚½ãƒƒãƒ‰ã‚’ãƒã‚¤ãƒ³ãƒ‰'))

  # coderay c
  static VALUE rb_hello_message(VALUE self) {
    Hello *hello;
    const char *message;
    TypedData_Get_Struct( /* Unwrap the target. */
      self, Hello, &rb_hello_type, hello);
    message = hello_message(hello); /* Call. */
    return rb_str_new_cstr(message); /* C -> Ruby */
  }

= Build1\n(('note:ãƒ“ãƒ«ãƒ‰1'))

  # coderay ruby
  # extconf.rb
  require "mkmf"
  # Accept --with-libhello-*.
  dir_config("libhello")
  have_header("hello.h")
  have_library("hello", "hello_new")

  create_makefile("hello")

= Build2\n(('note:ãƒ“ãƒ«ãƒ‰2'))

  % ruby extconf.rb \
      --with-libhello-dir=../../libhello
  % make
  (hello.so is generated.)

= Use\n(('note:ä½¿ã†'))

  % LD_LIBRARY_PATH=../../libhello/lib \
      irb -I .
  irb(main):001:0> require "hello"
  => true
  irb(main):002:0> hello = Hello.new
  => #<Hello:0x00000002ae0e28>
  irb(main):003:0> hello.message
  => "Hello"

= C API: Merit\n(('note:C APIï¼šãƒ¡ãƒªãƒƒãƒˆ'))

  * Can create bindings\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½œã‚Œã‚‹'))
  * (('wait'))Can use only with C and Ruby knowledge\n
    (('note:Cã¨Rubyã‚’çŸ¥ã£ã¦ã„ã‚Œã°ä½¿ãˆã‚‹'))

= C API: Demerit\n(('note:C APIï¼šãƒ‡ãƒ¡ãƒªãƒƒãƒˆ'))

  * Many works for many (('note:target')) API\n
    (('note:å¯¾è±¡ã®APIãŒãŸãã•ã‚“ã‚ã‚‹ã¨ã‚„ã‚‹ã“ã¨ãŒå¤šã„'))
  * (('wait'))Users need C compiler to install\n
    (('note:ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ™‚ã«Cã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒå¿…è¦'))
    * Most Windows users don't have it\n
      (('note:å¤šãã®Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æŒã£ã¦ã„ãªã„'))

= C API: Windows users\n(('note:C APIï¼šWindowsãƒ¦ãƒ¼ã‚¶ãƒ¼'))

  * How to install extension library...?\n
    (('note:æ‹¡å¼µãƒ©ã‚¤ãƒ–ãƒªãƒ¼ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã™ã‚‹ã«ã¯ã©ã†ã™ã‚Œã°â€¦ï¼Ÿ'))
    * (('wait'))Install C compiler (('note:(DevKit)'))\n
      (('note:Cã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ï¼ˆDevKitï¼‰ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«'))
    * (('wait'))Distribute built binary\n
      (('note:ãƒ“ãƒ«ãƒ‰æ¸ˆã¿ãƒã‚¤ãƒŠãƒªãƒ¼ã‚’é…å¸ƒ'))

= C API: Fat gem\n(('note:C APIï¼šfat gem'))

  * Gem includes built binaries\n
    (('note:ãƒ“ãƒ«ãƒ‰æ¸ˆã¿ãƒã‚¤ãƒŠãƒªãƒ¼å…¥ã‚Šgem'))
    * (('note:(Mainly)')) Provided for Windows users\n
      (('note:ä¸»ã«Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼å‘ã‘ã«æä¾›'))
  * (('wait'))Windows users don't need C compilerğŸ˜¼\n
    (('note:Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯Cã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã‚’ç”¨æ„ã—ãªãã¦ã‚ˆã„'))

= Fat gem: Paths\n(('note:fat gemï¼šãƒ‘ã‚¹'))

Built binaries included in gem:\n
(('note:gemå†…ã«ãƒ“ãƒ«ãƒ‰æ¸ˆã¿ãƒã‚¤ãƒŠãƒªãƒ¼ãŒå…¥ã£ã¦ã„ã‚‹ï¼š'))

  ./lib/hello.rb
  ./lib/2.1/hello.so # For Ruby 2.1
  ./lib/2.2/hello.so # For Ruby 2.2
  ./lib/2.3/hello.so # For Ruby 2.3

= Fat gem: Load\n(('note:fat gemï¼šèª­ã¿è¾¼ã¿'))

  # coderay ruby
  # hello.rb
  begin
    major, minor, = RUBY_VERSION.split(".")
    # e.g.: require "2.3/hello.so"
    require "#{major}.#{minor}/hello.so"
  rescue LoadError
    require "hello.so"
  end

= Fat gem: Paths: Bindings\n(('note:fat gemï¼šãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®æ™‚ã®ãƒ‘ã‚¹'))

  ./lib/hello.rb
  ./lib/2.1/hello.so # For Ruby 2.1
  ./lib/2.2/hello.so # For Ruby 2.2
  ./lib/2.3/hello.so # For Ruby 2.3
  # â†“Target library's DLL
  ./vendor/local/bin/hello.dll

= Fat gem: Load: Bindings\n(('note:fat gemï¼šãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã®æ™‚ã®èª­ã¿è¾¼ã¿'))

  # coderay ruby
  # hello.rb
  if /mingw|mswin/ =~ RUBY_PLATFORM
    ENV["PATH"] += # For finding DLL
      ";#{__dir__}\\..\\vendor\\local\\bin"
  end
  begin
    major, minor, = RUBY_VERSION.split(".")
    # ...

= Fat gem: How to create?\n(('note:fat gemï¼šä½œã‚Šæ–¹'))

  (1) (('wait'))Build DLLs\n
      (('note:DLLã‚’ãƒ“ãƒ«ãƒ‰'))
  (2) (('wait'))Bundle DLLs to gem\n
      (('note:gemã«DLLã‚’ãƒãƒ³ãƒ‰ãƒ«'))

= Fat gem: How to build?\n(('note:fat gemï¼šãƒ“ãƒ«ãƒ‰æ–¹æ³•'))

  * (('wait'))Build on Windows with C compiler\n
    (('note:Windowsä¸Šã§Cã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã§ãƒ“ãƒ«ãƒ‰'))
  * (('wait'))Build on GNU/Linux or OS X with C cross compiler\n
    (('note:GNU/Linuxã¾ãŸã¯OS Xä¸Šã§Cã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ã§ãƒ“ãƒ«ãƒ‰'))
    * Popular\n
      (('note:ã“ã¡ã‚‰ãŒä¸€èˆ¬çš„'))

= How to cross compile\n(('note:ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ–¹æ³•'))

  (1) Cross compile target Rubyies\n
      (('note:å¯¾è±¡ã®Rubyã‚’ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«'))
  (2) Run (({extconf.rb})) with target Rubies\n
      (('note:å¯¾è±¡ã®Rubyã§(({extconf.rb}))ã‚’å®Ÿè¡Œ'))
  (3) Cross compile\n
      (('note:ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«'))

= Fat gem helper gems\n(('note:fat gemä½œæˆæ”¯æ´gem'))

  * rake-compiler
    * Cross compiling and bundling\n
      (('note:ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ã¨ãƒãƒ³ãƒ‰ãƒ«æ”¯æ´'))
  * rake-compiler-dock
    * Prepares build environment\n
      (('note:ãƒ“ãƒ«ãƒ‰ç’°å¢ƒç”¨æ„æ”¯æ´'))

= Fat gem and bindings\n(('note:fat gemã¨ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°'))

  * Bindings need DLL of target library\n
    (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã¯å¯¾è±¡ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã®DLLã‚‚å¿…è¦'))
  * Target library should be also cross compiled\n
    (('note:å¯¾è±¡ãƒ©ã‚¤ãƒ–ãƒ©ãƒªãƒ¼ã‚‚ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ãŒå¿…è¦'))

= How to cross compile1\n(('note:ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ–¹æ³•1'))

For GNU Autotools:

  % ./configure \
      --prefix=vendor/local \
      --host=x86_64-w64-mingw32
  % make
  % make install

= How to cross compile2\n(('note:ã‚¯ãƒ­ã‚¹ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«æ–¹æ³•2'))

For CMake:

  % cmake . \
      -DCMAKE_INSTALL_PREFIX=vendor/local \
      -DCMAKE_SYSTEM_NAME=Windows \
      -DCMAKE_SYSTEM_PROCESSOR=x64 \
      -DCMAKE_C_COMPILER=x86_64-w64-mingw32-gcc
  % make
  % make install

= How to bundle\n(('note:ãƒãƒ³ãƒ‰ãƒ«æ–¹æ³•'))

  # coderay ruby
  # #{gem_name}.gemspec
  Gem::Specification.new do |spec|
    # ...
    spec.files +=
      Dir.glob("vendor/local/**/*")
    # ...
  end

= Fat gem & Windows users\n(('note:fat gemã¨Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼'))

  * Windows users can't use bindings created by C API\n
    (('note:ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ãŒé›£ã—ãã¦Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯C APIã§ä½œæˆã•ã‚ŒãŸãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ããªã„'))
    * Difficult to install
  * (('wait'))Fat gem makes bindings easy to install for Windows users\n
    (('note:fat gemãŒã‚ã‚Œã°ç°¡å˜ã«ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã§ãã‚‹'))

= C API: Demerit (reprise)\n(('note:C APIï¼šãƒ‡ãƒ¡ãƒªãƒƒãƒˆï¼ˆå†æ²ï¼‰'))

  * Many works for many (('note:target')) API\n
    (('note:å¯¾è±¡ã®APIãŒãŸãã•ã‚“ã‚ã‚‹ã¨ã‚„ã‚‹ã“ã¨ãŒå¤šã„'))
  * (('wait'))Users need C compiler to install\n
    (('note:ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«æ™‚ã«Cã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãƒ¼ãŒå¿…è¦'))
    * Most Windows users don't have it\n
      (('note:å¤šãã®Windowsãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯æŒã£ã¦ã„ãªã„'))

= SWIG

(('tag:center'))
Simplified Wrapper and Interface Generator

  * (('wait'))Generate bindings by C API\n
    (('note:C APIã‚’ä½¿ã£ãŸãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç”Ÿæˆ'))
  * (('wait'))Reduce hand writing codes\n
    (('note:æ‰‹æ›¸ãã®ã‚³ãƒ¼ãƒ‰ã‚’æ¸›ã‚‰ã›ã‚‹'))

= SWIG: How to use\n(('note:SWIGï¼šä½¿ã„æ–¹'))

  (1) Generate bindings\n
      (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ç”Ÿæˆ'))
  (2) (('wait'))Build bindings (('note:(Same as C API)'))\n
      (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ãƒ“ãƒ«ãƒ‰ï¼ˆC APIã¨åŒã˜ï¼‰'))
  (3) (('wait'))Use bindings (('note:(Same as C API)'))\n
      (('note:ãƒã‚¤ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ã‚’ä½¿ã†ï¼ˆC APIã¨åŒã˜ï¼‰'))

= SWIG: Generate\n(('note:SWIGï¼šç”Ÿæˆ'))
